---
import "../styles/global.css";
import '../styles/prism.css';
import { ViewTransitions } from "astro:transitions";
import '@fontsource/prompt';
import '@fontsource/zilla-slab';
import site from '@config/site';
import { 
  generatePageSchema, 
  safeSchemaGeneration,
  type PageSchemaOptions,
  type ServiceData,
  type FAQData,
  type PersonData
} from '@lib/schema-generators';

interface Props {
  title: string;
  description: string;
  image?: string;
  datePublished?: string,
  dateModified: string,
  metaImage?: {
    src: string,
    height: string,
    width: string,
  },
  path?: string,
  article?: boolean,
  author?: {
    name: string,
    url?: string,
  },
  pageType?: 'article' | 'service' | 'faq' | 'home' | 'about' | 'contact' | 'default';
  serviceData?: ServiceData;
  faqs?: FAQData[];
  includeBreadcrumbs?: boolean;
  includeLocalBusiness?: boolean;
}

const canonicalURL = new URL(Astro.url.pathname, Astro.site);

const { 
  title = site.title,
  description = site.description,
  datePublished,
  dateModified = new Date().toISOString(),
  metaImage = {
    src: site.image.src,
    height: site.image.height,
    width: site.image.width,
  },
  path = Astro.url.pathname,
  article = false,
  author = {
    name: site.author.name,
    url: site.author.url,
  },
  pageType = article ? 'article' : 'default',
  serviceData,
  faqs,
  includeBreadcrumbs = true,
  includeLocalBusiness = false,
  } = Astro.props;

  // Generate enhanced schema using new utility functions with error handling
  const schemaOptions: PageSchemaOptions = {
    pageType,
    title,
    description,
    path,
    datePublished,
    dateModified,
    author: author ? {
      name: author.name,
      url: author.url
    } : undefined,
    serviceData,
    faqs,
    includeBreadcrumbs,
    includeLocalBusiness
  };

  // Enhanced error handling for schema generation with detailed logging
  let pageSchemas: any[] = [];
  try {
    pageSchemas = generatePageSchema(schemaOptions);
    
    // Validate that we have valid schemas
    if (!Array.isArray(pageSchemas)) {
      throw new Error('Schema generation returned invalid format');
    }
    
    // Filter out any null or invalid schemas
    pageSchemas = pageSchemas.filter(schema => {
      if (!schema || typeof schema !== 'object') {
        console.warn('Invalid schema object filtered out:', schema);
        return false;
      }
      if (!schema['@context'] || !schema['@type']) {
        console.warn('Schema missing required @context or @type:', schema);
        return false;
      }
      return true;
    });
    
  } catch (error) {
    console.error('Schema generation failed:', error);
    console.error('Schema options that caused failure:', schemaOptions);
    
    // Fallback to basic schema with additional error handling
    const fallbackSchema = safeSchemaGeneration(() => {
      const baseSchema: any = {
        '@context': 'https://schema.org',
        '@type': article ? 'Article' : 'WebPage',
        url: `${site.url}${path}`,
        name: title,
        description: description,
        inLanguage: site.siteLanguage,
        dateModified: dateModified
      };
      
      // Safely add author information
      if (author?.name || site.author?.name) {
        baseSchema.author = {
          '@type': 'Person',
          name: author?.name || site.author.name,
          ...(author?.url || site.author.url ? { url: author?.url || site.author.url } : {})
        };
      }
      
      // Add publisher for articles
      if (article) {
        baseSchema.publisher = {
          '@type': 'Organization',
          name: site.titleAlt,
          logo: {
            '@type': 'ImageObject',
            url: `${site.url}${site.image.src}`
          }
        };
        
        if (datePublished) {
          baseSchema.datePublished = datePublished;
        }
      }
      
      return [baseSchema];
    }, []);
    
    pageSchemas = fallbackSchema || [];
  }
  
  // Final validation to ensure we have at least one valid schema
  if (pageSchemas.length === 0) {
    console.warn('No valid schemas generated, creating minimal fallback');
    pageSchemas = [{
      '@context': 'https://schema.org',
      '@type': 'WebPage',
      url: `${site.url}${path}`,
      name: title,
      description: description,
      inLanguage: site.siteLanguage
    }];
  }

---

<!-- Global Metadata -->
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- Resource Hints for Performance -->
<!-- DNS Prefetch for external resources - improves connection time -->
<link rel="dns-prefetch" href="//fonts.googleapis.com" />
<link rel="dns-prefetch" href="//fonts.gstatic.com" />
<link rel="dns-prefetch" href="//www.google-analytics.com" />
<link rel="dns-prefetch" href="//www.googletagmanager.com" />
<link rel="dns-prefetch" href="//clarity.microsoft.com" />
<link rel="dns-prefetch" href="//webmention.io" />
<link rel="dns-prefetch" href="//mm-micropub-to-github.herokuapp.com" />
<link rel="dns-prefetch" href="//giscus.app" />
<link rel="dns-prefetch" href="//cdnjs.cloudflare.com" />
<link rel="dns-prefetch" href="//unpkg.com" />

<!-- Preconnect for critical external resources - establishes early connections -->
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

<!-- Analytics preconnect - critical for tracking -->
<link rel="preconnect" href="https://www.google-analytics.com" />
<link rel="preconnect" href="https://www.googletagmanager.com" />

<!-- Conditional preconnect for analytics and tracking services -->
{(pageType === 'service' || pageType === 'contact' || pageType === 'home') && (
  <link rel="preconnect" href="https://clarity.microsoft.com" />
)}

<!-- Webmention and social services preconnect -->
<link rel="preconnect" href="https://webmention.io" />

<!-- Conditional preconnect for comment system on article pages -->
{pageType === 'article' && (
  <link rel="preconnect" href="https://giscus.app" />
)}

<!-- Note: Font preloading for fontsource fonts is handled automatically by Astro -->
<!-- Fontsource fonts are bundled and optimized during build with proper font-display: swap -->
<!-- Manual preloading of hashed font files would require dynamic resolution -->

<!-- Preload critical images -->
<link rel="preload" href={metaImage.src} as="image" />
<link rel="preload" href="/favicon.svg" as="image" type="image/svg+xml" />

<!-- Conditional preload for service-specific assets -->
{pageType === 'service' && (
  <link rel="preload" href="/images/theme/alok-logo.png" as="image" />
)}

<!-- Conditional preload for home page hero image -->
{pageType === 'home' && (
  <link rel="preload" href="/images/theme/alok-logo.png" as="image" />
)}

<link
    rel="alternate"
    type="application/rss+xml"
    title={site.title}
    href={`${Astro.site}rss.xml`}
/>
<link type="text/plain" rel="author" href="https://alokprateek.in/humans.txt" />

<!-- Astro version -->
<meta name="generator" content={Astro.generator} />

<!-- Canonical URL -->
<link rel="canonical" href={canonicalURL} />

<!-- Primary Meta Tags -->
<title>{title}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />
<meta name="image" content={metaImage.src} />

<!-- Indie Web -->
<link rel="pingback" href={site.pingbackUrl} />
<link rel="webmention" href={site.webmentionUrl} />
<link rel="micropub" href={site.micropubUrl} />

<!-- Open Graph / Facebook -->
<meta property="og:site_name" content={site.facebook} />
<meta property="og:type" content={article ? 'article' : 'website'} />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={metaImage.src} />
<meta property="og:image:width" content={String(metaImage.width)} />
<meta property="og:image:height" content={String(metaImage.height)} />

<!-- Twitter -->
<meta name="twitter:creator" content={site.twitter} />
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={metaImage.src} />

<!-- PWA WebManifest -->
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
<link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">

<link rel="apple-touch-icon" sizes="57x57" href="/favicons/favicon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/favicons/favicon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/favicons/favicon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/favicons/favicon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/favicons/favicon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/favicons/favicon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/favicons/favicon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/favicons/favicon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/favicon-180x180.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="192x192" href="/favicons/favicon-192x192.png">



<meta name="msapplication-TileColor" content="#000000">
<meta name="msapplication-TileImage" content="/favicons/mstile-150x150.png">
<meta name="msapplication-config" content="/favicons/browserconfig.xml">
<meta name="theme-color" content="#000000">

<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#202020">

<ViewTransitions />

<!-- Enhanced Schema.org JSON-LD with multiple schema types and error handling -->
{pageSchemas && pageSchemas.length > 0 && pageSchemas.map((schema, index) => {
  try {
    // Additional validation before JSON stringification
    if (!schema || typeof schema !== 'object') {
      console.warn(`Skipping invalid schema at index ${index}:`, schema);
      return null;
    }
    
    // Attempt to stringify with error handling for circular references
    let jsonString;
    try {
      jsonString = JSON.stringify(schema, null, 0);
    } catch (stringifyError) {
      console.error(`JSON stringify error for schema ${index}:`, stringifyError);
      console.error('Problematic schema object:', schema);
      return null;
    }
    
    // Validate that we have a valid JSON string
    if (!jsonString || jsonString === '{}' || jsonString === 'null') {
      console.warn(`Empty or invalid JSON for schema ${index}`);
      return null;
    }
    
    return (
      <script
        type="application/ld+json"
        id={`pageSchema-${index}`}
        set:html={jsonString}
      />
    );
  } catch (error) {
    console.error(`Schema rendering error for schema ${index}:`, error);
    console.error('Schema that caused error:', schema);
    return null;
  }
}).filter(Boolean)}

<script is:inline>
  function addCopyCodeButtons() {
    let copyButtonLabel = "✂️ copy";
    let codeBlocks = Array.from(document.querySelectorAll("pre"));

    async function copyCode(codeBlock, copyButton) {
        const codeText = codeBlock.innerText;
        const buttonText = copyButton.innerText;
        const textToCopy = codeText.replace(buttonText, "");

        await navigator.clipboard.writeText(textToCopy);
        copyButton.innerText = "✅ copied!";

        setTimeout(() => {
            copyButton.innerText = copyButtonLabel;
        }, 2000);
    }

    for (let codeBlock of codeBlocks) {
        const wrapper = document.createElement("div");
        wrapper.style.position = "relative";

        const copyButton = document.createElement("button");
        copyButton.innerText = copyButtonLabel;
        copyButton.classList = "copy-code";

        codeBlock.setAttribute("tabindex", "0");
        codeBlock.appendChild(copyButton);

        codeBlock.parentNode.insertBefore(wrapper, codeBlock);
        wrapper.appendChild(codeBlock);

        copyButton?.addEventListener("click", async () => {
            await copyCode(codeBlock, copyButton);
        });
    }
}

document.addEventListener("DOMContentLoaded", () => addCopyCodeButtons());
document.addEventListener("astro:after-swap", () => addCopyCodeButtons());
</script>